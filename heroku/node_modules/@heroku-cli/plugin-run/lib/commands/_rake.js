"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
// tslint:disable:file-name-casing
const command_1 = require("@heroku-cli/command");
const completions_1 = require("@heroku-cli/command/lib/completions");
const cli_ux_1 = require("cli-ux");
const dyno_1 = require("../lib/dyno");
const helpers_1 = require("../lib/helpers");
class RunRake extends command_1.Command {
    async run() {
        let { flags, argv } = this.parse(RunRake);
        let opts = {
            heroku: this.heroku,
            app: flags.app,
            command: helpers_1.buildCommand(['rake', ...argv]),
            size: flags.size,
            'exit-code': flags['exit-code'],
            env: flags.env,
            'no-tty': flags['no-tty'],
            attach: true
        };
        let dyno = new dyno_1.default(opts);
        try {
            await dyno.start();
        }
        catch (err) {
            if (err.exitCode) {
                cli_ux_1.default.error(err);
                process.exit(err.exitCode);
            }
            else {
                throw err;
            }
        }
    }
}
RunRake.hidden = true;
RunRake.strict = false;
RunRake.flags = {
    app: command_1.flags.app({ description: 'parent app used by review apps', required: true }),
    remote: command_1.flags.remote(),
    size: command_1.flags.string({ char: 's', description: 'dyno size', completion: completions_1.DynoSizeCompletion }),
    'exit-code': command_1.flags.boolean({ char: 'x', description: 'passthrough the exit code of the remote command' }),
    env: command_1.flags.string({ char: 'e', description: "environment variables to set (use ';' to split multiple vars)" }),
    'no-tty': command_1.flags.boolean({ description: 'force the command to not run in a tty' }),
};
exports.default = RunRake;
